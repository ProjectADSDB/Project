# -*- coding: utf-8 -*-
"""trusted_zone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YuHEXkebK_kV8nlHNjtxcD8XhJMtDb4J
"""

# Import necessary libraries
import os
import shutil
import subprocess


# Mount Google Drive to Colab
#from google.colab import drive
#drive.mount('/content/drive')


# Install and Setup PostgreSQL
# Replace !apt-get command

def update_tables(dump_path):
  # Path for the dump file from Google Drive
    drive_path = "/content/drive/MyDrive/ADSDB/formatted/dumpfile.sql"

    # Check if the dumpfile exists in the Google Drive
    if not os.path.exists(drive_path):
        print("Dump file not found in Google Drive.")
        return

    # Copy the dumpfile from Google Drive to Colab's environment
    shutil.copy(drive_path, dump_path)

    # Create a temporary .pgpass file for authentication
    with open("/root/.pgpass", "w") as f:
        f.write("*:*:*:adsdb:adsdb")
    os.chmod("/root/.pgpass", 0o600)  # Set the required permissions

    # Restore the database using psql command
    try:
        subprocess.run(['PGPASSFILE=/root/.pgpass', 'pg_dump', '-h', 'localhost', '-U', 'adsdb', '-d', 'adsdb', '-f', dump_path], shell=True)
        print("Restoration successful!")
    except Exception as e:
        print(f"Error during restoration: {e}")

    """
    try:
        #!PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "SELECT table_name FROM information_schema.tables WHERE table_schema='public';"

        # Query the contents of the inflation_rate_2008 table
        #print("SELECT * FROM inflation_rate_2008: ")
        #!PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "SELECT * FROM inflation_rate_2008;"
        !PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name LIKE 'inflation_rate_%';"

    except Exception as e:
        print(f"Error during query: {e}")

     """





# Run the function
update_tables("/content/dumpfile.sql")

table_names = ['employment_rate', 'house_price_index_weights', 'inflation_rate', 'house_price_index']
final_name = ''


def merge_table(table_name):
    string = table_name
    final_name = 'final_' + table_name
    try:
        cmd = 'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -t -A -c "SELECT table_name FROM information_schema.tables WHERE table_schema=\'public\' AND table_name LIKE \'{string}_____\'"'
        results = subprocess.run(cmd, shell=True, capture_output=True, text=True).stdout
        if results:
            union_query = "SELECT * FROM " + " UNION ALL SELECT * FROM ".join(results)
            print(union_query)
            #!PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "{union_query}"
            create_table_query = f"CREATE TABLE {final_name} AS ({union_query});"
            subprocess.run(['PGPASSFILE=/root/.pgpass', 'psql', '-h', 'localhost', '-U', 'adsdb', '-d', 'adsdb', '-c', create_table_query], shell=True)
    except Exception as e:
        print(f"Error in merge_table function: {e}")

def show_table(table_name):
  display_query = f"SELECT * FROM {table_name} LIMIT 20;"
  cmd = f'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "{display_query}"'
  subprocess.run(cmd, shell=True)

def get_table_length(table_name):
  count_query = f"SELECT COUNT(*) FROM {table_name};"
  cmd = f'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "{count_query}"'
  subprocess.run(cmd, shell=True)

def drop_non_final_tables():
    try:
        cmd = f'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -t -A -c "SELECT table_name FROM information_schema.tables WHERE table_schema=\'public\' AND table_name NOT LIKE \'final%\';"'
        results = subprocess.run(cmd, shell=True, capture_output=True, text=True).stdout.split()
        if results:
            for table_name in results:
                drop_query = f"DROP TABLE {table_name} CASCADE;"
                cmd = f'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "{drop_query}"'
                subprocess.run(cmd, shell=True)
                print(f"Dropped table: {table_name}")
        else:
            print("No non-final tables to drop.")
    except Exception as e:
        print(f"Error during table drop: {e}")

get_table_length('house_price_index_weights_2008')

for table_name in table_names:
    merge_table(table_name)

drop_non_final_tables()
updated_names = ['final_employment_rate', 'final_house_price_index_weights', 'final_inflation_rate', 'final_house_price_index']
get_table_length(updated_names[3])
show_table(updated_names[3])
for ta in updated_names:
  get_table_length(ta)

cmd = f'PGPASSFILE=/root/.pgpass psql -h localhost -U adsdb -d adsdb -c "SELECT table_name FROM information_schema.tables WHERE table_schema=\'public\';"'
subprocess.run(cmd, shell=True)
show_table('final_employment_rate')

def save_to_drive(dump_path, drive_path):
    try:
        # Try to copy the dump file to the specified drive path
        shutil.copy(dump_path, drive_path)
        # Remove the original dump file after copying
        os.remove(dump_path)
    except Exception as e:
        print(f"Error saving to Google Drive: {e}")


# Path for the dump file
dump_path = "/content/dumpfile.sql"
drive_path = "/content/drive/MyDrive/ADSDB/trusted/dumpfile.sql"

# Create a temporary .pgpass file for authentication
with open("/root/.pgpass", "w") as f:
    f.write("*:*:*:adsdb:adsdb")
os.chmod("/root/.pgpass", 0o600)  # Set the required permissions

# Use the pg_dump command to dump the data
try:
    cmd = f'PGPASSFILE=/root/.pgpass pg_dump -h localhost -U adsdb -d adsdb -f "{dump_path}"'
    subprocess.run(cmd, shell=True)
    save_to_drive(dump_path, drive_path)
except Exception as e:
    print(f"Error during pg_dump: {e}")

    # Clean up the temporary password file
os.remove("/root/.pgpass")